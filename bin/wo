#!/usr/bin/perl
use File::Temp q(tempfile);
use Getopt::Long;
use JSON;
use LWP::UserAgent;
use POSIX;
use POSIX::strptime qw(strptime);
use Time::Local;
use strict;

sub max(@);

# wo = "work on".  Simple cli time tracking.
# Mark J. Reed, 2008
sub USAGE 
{ 
   my $rc = shift;
   open(my $out, ">&" . (1 + ~~!!$rc)) or die;
   print $out "Usage: $0 [-f] [-t] [-l] [-n] [\@time] task\n"; 
   exit($rc); 
}

my $TS_URL    = 'http://strange.turner.com:5984/timesheets';
my $TS_FORMAT = '%Y%m%d%H%M';
my @SKIP      = (qw(lunch home), 'doc appt');

my %opts;
GetOptions(\%opts, 'csv|c',  'delete|d',    'edit|e', 
                   'file|f', 'timesheet|t', 'list|l', 
                   'number|n=i', 'replace|r') or USAGE(1);

my $now = time - ($opts{number} + !!($0 =~ /ts/)) * 604800;
my @now = localtime $now;
my $start_of_week = $now - $now[0] - $now[1] * 60 - $now[2] * 3600 - 
                           (($now[6]||7) - 1) * 86400;
my $ts_doc = $TS_URL . strftime "/%Y-%m-%d", localtime $start_of_week;

if ($opts{file})
{
    print "$ts_doc\n";
    exit 0;
}

my $ua = LWP::UserAgent->new;
my $resp = $ua->get($ts_doc);
my $ts;
if ($resp->is_success)
{
    $ts = decode_json($resp->decoded_content);
}
else
{
    $ts = { entries => {} };
}

if ($opts{edit}) {
  my ($fh, $filename) = tempfile;
  my $old_json = JSON::XS->new->canonical->pretty->encode($ts);
  print $fh $old_json;
  close $fh;
  my $EDITOR = $ENV{VISUAL} || $ENV{EDITOR} || 'vi';
  if (0 == system(split(' ', $EDITOR), $filename)) {
    my $new_json;
    {
      open(my $fh, "<$filename") or die;
      local $/ = undef;
      $new_json =  <$fh>;
    }
    if ($new_json eq $old_json) {
      print "$0: No changes to save.\n";
      exit 0;
    }
    my $resp = $ua->request(
      HTTP::Request->new( 
        PUT => $ts_doc, 
        [ 'Content-Type' => 'application/json' ], 
        $new_json ));
    die $resp->status_line unless $resp->is_success;
    exit 0;
  } else {
    die "$0: Nonzero exit status from $EDITOR. Changes not saved.\n";
  }
}

elsif ($opts{list})
{
    foreach my $k (sort { $a <=> $b } keys %{$ts->{entries}}) {
        my $v = $ts->{entries}{$k};
        print format_entry($k,$v),"\n";
    }
}
elsif ($opts{timesheet} || ($0 =~ /ts/))
{
    my %ts = ();
    my @entries = ();
    my $max;
    my @order = ();
    foreach my $key (sort { $a <=> $b } keys %{$ts->{entries}}) {
        my $what = $ts->{entries}{$key};
        push @order, $what unless grep { $_ eq $what } @order;
        my $when = timelocal(strptime($key, $TS_FORMAT));
        push @entries, [$when, $what];
        $max = length $what if (length $what) > $max;
    }

    my @cur = ();
    for (sort { $a->[0] <=> $b->[0] } @entries)
    {
        my ($when, $what) = @$_;
        next if $what eq $cur[1];
        if (@cur)
        {
            my @when = localtime $when;

            my $then = $cur[0];
            my @then = localtime $then;
            while ($when[6] != $then[6])
            {
                my $midnight = timelocal(59,59,23,@then[3..$#then]) + 1;
                my $hours = 
                    floor((($midnight - $then) / 3600.0 + 0.125)/0.25)*0.25;
                $ts{$cur[1]}[$then[6]] += $hours;
                $then = $midnight;
                @then = localtime $then;
            }
            my $hours = ceil((($when - $then) / 3600.0)/0.25)*0.25;
            $ts{$cur[1]}[$when[6]] += $hours;
        }
        @cur = ($when, $what);
    }
    my $now = time;
    my $day = (localtime $now)[6];
    my $hours = ($now - $cur[0]) / 3600.0;
    $hours = int(($hours + 0.125) / 0.25) * 0.25;
    $ts{$cur[1]}[$day] += $hours;
    
    if (!$opts{csv})
    {
        print "Week of " . strftime("%F", localtime $start_of_week)  . "\n";
        printf "%-${max}s", "Activity";
        foreach my $wday (qw(Mon Tue Wed Thu Fri Sat Sun TOTAL))
        {
            printf "%7s", $wday;
        }
        print "\n";
        my @hours = ();
        foreach my $activity (@order) {
            my $week = $ts{$activity};
            printf "%-${max}s", $activity;
            my $hours = 0;
            for (my $i=1; $i<=7; ++$i)
            {   
                my $time = $week->[$i%7];
                my $skip = grep { $_ eq $activity } @SKIP;
                $hours += $time;
                $hours[$i] += $time unless $skip;
                print format_hours($time);
            }
            print format_hours($hours),"\n";
        }
        printf "%-${max}s", "TOTALS";
        $hours = 0;
        for (my $i=1; $i<=7; ++$i)
        {
            $hours += $hours[$i];
            print format_hours($hours[$i]);
        }
        print format_hours($hours),"\n";
    }
    else
    {
        print join(',', qw(Activity Mon Tue Wed Thu Fri Sat Sun TOTAL)),"\n";
        my @hours = ();
        while (my ($activity, $week) = each %ts)
        {
            print $activity;
            my $hours = 0;
            for (my $i=1; $i<=7; ++$i)
            {   
                my $time = $week->[$i%7];
                my $skip = grep { $_ eq $activity } @SKIP;
                $hours += $time;
                $hours[$i] += $time unless $skip;
                print ",$time";
            }
            print ",$hours\n";
        }
        print "TOTALS";
        $hours = 0;
        for (my $i=1; $i<=7; ++$i)
        {
            $hours += $hours[$i];
            print ",",$hours[$i];
        }
        print ",$hours\n";
    }
}
elsif (@ARGV)
{
    (my $what = join(' ', @ARGV)) =~ s/\n/\\n/g;
    if ($what =~ s/^@(\S+)\s+//)
    {
        my $dt= $1;
        my @when;
        if ($dt =~ /\d{4}/ && (@when = strptime($dt, "%H%M")))
        {
            @now[0..2] = @when[0..2];
        }
        elsif ($dt =~ /\d{8}/ && (@when = strptime($dt, "%m%d%H%M")))
        {
            @now[0..4] = @when[0..4];
        }
        else
        {
            die "$0: unrecognized date/time format ' $dt'\n";
        }
        while (timelocal(@now)  > $now)
        {
            $now[3]--;
        }
    }

    my $key = strftime($TS_FORMAT, @now);
    if ($opts{delete})
    {
        delete $ts->{$key};
    }
    else
    {
        if ($opts{replace})
        {
            $key = max  keys %{$ts->{entries}};
        }
        $ts->{entries}{$key} = $what;
    }
    my $resp = $ua->request(
      HTTP::Request->new( 
        PUT => $ts_doc, 
        [ 'Content-Type' => 'application/json' ], 
        encode_json($ts) ));
     die $resp->status_line unless $resp->is_success;
}
elsif (%{$ts->{entries}})
{
    my $max = max keys %{$ts->{entries}};
    if ($opts{delete})
    {
       delete $ts->{entries}{$max};
       my $resp = $ua->request(
         HTTP::Request->new( 
           PUT => $ts_doc, 
           [ 'Content-Type' => 'application/json' ], 
           encode_json($ts) ));

       die $resp->status_line unless $resp->is_success;
       $max = max keys %{$ts->{entries}};
    }
    print format_entry($max, $ts->{entries}{$max}),"\n";
}

sub format_entry
{
    my ($timestamp, $desc) = @_;
    my $time = timelocal(strptime($timestamp, $TS_FORMAT));
    return strftime("%Y-%m-%d@%H:%M", localtime($time)) . ": $desc";
}

sub format_hours
{
    my ($value, $skip) = @_;
    return sprintf("%7s", '-') unless $value;
    my $formatted = sprintf("%.2f", $value);
    return sprintf("%7s", $skip ? "($value)" : $value);
}

sub max(@)
{
    my $max = shift;
    for (@_)
    {
        $max = $_ if $_ > $max;
    }
    return $max;
}
